# Introduction
This is a project that I worked on in my Software Engineering class in the fall of 2018. It is an implementation of Tic-Tac-Toe in Java and was created using the Gradle build tool. In this project, the professor instructed us students to use the model-view-controller technique. The professor included a few lines of code as a starting point and left the rest of the project to the students. The professor also included unit tests to use with Gradle. The project consists of 3 classes: TicTacToe.java, TicTacToeModel.java, and TicTacToeView.java.
# The Program
In the model-view-controller programming technique, the program is separated into three parts. The model contains the logic of the program and uses any classes or objects that are created. The view handles the output of the model to the screen or to a graphical user interface. It also receives the user input. Connecting the two is the controller. The controller takes the model's logic and passes it onto the view. Similarly, the controller also takes the view's user input and gives it to the model for use.

In the original version of this project, the users play the game in the command prompt. The first user places Xs, while the second user places Os. In the TicTacToeModel class, an enum called Mark is used to represent the marks on the board. The enum's values include X, O, and EMPTY. Similarly, an enum called Result is used to represent the winner of the game. These values include X, O, TIE, and NONE. Both enums include toString methods that are used by the view.

The game board is a 2D array called grid consisting of Mark enums isntantiated with the EMPTY value. The size of the grid is specified in the TicTacToeModel constructor. Two important methods in the TicTacToeModel are the isValidSquare and isSquareMarked methods. The isValidSquare method receives two integers as arguments that represent the row and column of the square that is to be checked in the grid. If the specified square is within the bounds of the grid, then the method returns a true boolean. If it is not, it returns a false boolean. The isSquareMarked method also receives two integers as arguments and uses them to specify a location on the grid. If the value of the Mark in that location is neither X nor O, then it returns a true boolean. If it is one of those values, it returns a false boolean.

The TicTacToeModel contains a boolean called isXTurn to keep track of whose turn it is. By default, the first player will be X, and the second player will be O. The makeMark method uses both the isValidSquare and isSquareMarked methods. It receives two integers as arguments that represent the row and column of the square to be marked. If the specified location is inside the grid and the Mark in that location is EMPTY, then it changes that Mark to the value of the current player. Then it sets the boolean isXTurn to true or false depending on whose turn just ended.

The isMarkWin method determines the winner of the game. Its only argument is a Mark enum. To win in Tic-Tac-Toe a player has to make 3 marks in a row in any direction. The method uses the given Mark and iterates through the grid to count the consecutive Marks. It iterates through the columns, row, and both diagonals. It uses the size parameter of the grid, which by default is 3, to compare the consecutive Marks it detects. If the number of consecutive Marks equals the size parameter of the grid, then the given Mark has won the game. If not, then the given Mark has not won the game. The method returns a boolean depending on if the Mark has won or not.

The isTie method uses the isMarkWin method to determine if there is no winner. It does this by calling the isMarkWin method for both X and O. If both calls return false, then it iterates through the grid to count the number of EMPTY Marks. If there are no EMPTY Marks, then there is a tie.

The getResult method uses the isMarkWin method to determine the result of the game after a turn. It initializes a Result enum to the NONE value. It then calls the isMarkWin method for both X and O to determine the winner. If a Mark has won, then the Result enum is changed to the respective value. It also checks for a tie using the isTie method. If there is a tie, then the Result enum is changed to TIE. If neither Mark has won and there is no tie, then the game is still in progress and the enum's value remains NONE. The method then returns the Result enum.

The TicTacToeModel also uses a method called isGameOver which simply calls the getResult method. It checks the Result enum and returns a boolean. If the enum's value is NONE, then the game is not over, and it returns false. Otherwise, it returns true.
# The GUI
Originally, the program displayed the grid to the command prompt, and the users would enter coordinates in the command prompt to place Marks. In the final version of this project, the program uses a graphical user interface to play the game. The workings of the controller were moved to the TicTacToeView class.

The TicTacToeView class uses a JPanel for the GUI. It creates a 2D array of JButtons with ActionListeners to represent the model's grid. It also contains a JLabel to show the winner. The ActionPerformed takes the place of the controller. It gets the source of the Action to determine which button in the grid was clicked. It uses the model's makeMark method to make a mark on the grid. Afterwards, it sets the JButton's text to either X or O, depending on whose turn it is.

After the Mark is made in the ActionPerformed, the TicTacToeView calls the method's isGameOver to check if the game is over. If it is, it displays the winner in the JLabel.

The TicTacToe main class just calls the constructors for the model and view objects and instantiates a JFrame to hold the JPanel.
# Conclusion
Using the model-view-controller programming technique, I separated the logic and the user interface for an implementation of Tic-Tac-Toe. This ensures that each part of the program has a specific task that it performs, instead of each part having many tasks. Using the Gradle build tool, I ran unit tests to confirm that the program was running as intended.
